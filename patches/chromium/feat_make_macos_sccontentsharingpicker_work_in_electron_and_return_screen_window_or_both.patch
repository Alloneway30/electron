From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 14 Jan 2025 15:50:29 -0800
Subject: feat: allow desktop capturer to return either screen, window or both
 and make MacOS SCContentSharingPicker work in Electron

This patch is a work in progress that contains assorted changes to make the MacOS SCContentSharingPicker upstream implementation work within Electron. If this comment is still in this patch during PR review, it is not ready for prime time

This patch can be removed after our desktopCapturer is refactored.

diff --git a/chrome/browser/media/webrtc/capture_policy_utils.cc b/chrome/browser/media/webrtc/capture_policy_utils.cc
index 36797f37627d534bd446e0d8270618722ed9a2fa..32222cb526dc047a02cd9382814edd71cca0a378 100644
--- a/chrome/browser/media/webrtc/capture_policy_utils.cc
+++ b/chrome/browser/media/webrtc/capture_policy_utils.cc
@@ -356,7 +356,9 @@ void FilterMediaList(std::vector<DesktopMediaList::Type>& media_types,
       media_types, [capture_level](const DesktopMediaList::Type& type) {
         switch (type) {
           case DesktopMediaList::Type::kNone:
-            NOTREACHED();
+            //TODO(review): are we able to remove this?
+            return capture_level < AllowedScreenCaptureLevel::kDesktop;
+            // NOTREACHED();
           // SameOrigin is more restrictive than just Tabs, so as long as
           // at least SameOrigin is allowed, these entries should stay.
           // They should be filtered later by the caller.
diff --git a/chrome/browser/media/webrtc/desktop_media_list_base.cc b/chrome/browser/media/webrtc/desktop_media_list_base.cc
index 08400be4d1bae18502d19beed6b2d9057e55dd4f..d83487885d566336d72bc5c4232d50a6a13ec3c2 100644
--- a/chrome/browser/media/webrtc/desktop_media_list_base.cc
+++ b/chrome/browser/media/webrtc/desktop_media_list_base.cc
@@ -12,9 +12,11 @@
 #include <set>
 #include <utility>
 
+#include "base/logging.h"
 #include "base/functional/bind.h"
 #include "base/hash/hash.h"
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -67,8 +69,9 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
       observer_->OnSourceAdded(i);
     }
   }
-
+  LOG(INFO)<< "Refresh callback_ is null: " << refresh_callback_.is_null() << ";";
   DCHECK(!refresh_callback_);
+  LOG(INFO) << "dcheck passed";
   refresh_callback_ = base::BindOnce(&DesktopMediaListBase::ScheduleNextRefresh,
                                      weak_factory_.GetWeakPtr());
   Refresh(true);
@@ -77,7 +80,13 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
 void DesktopMediaListBase::Update(UpdateCallback callback, bool refresh_thumbnails) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(sources_.empty());
-  DCHECK(!refresh_callback_);
+  #if BUILDFLAG(IS_MAC)
+   if (!ShouldUseSCContentSharingPicker()) {
+    DCHECK(!refresh_callback_);
+   };
+  #else
+    DCHECK(!refresh_callback_);
+  #endif
   refresh_callback_ = std::move(callback);
   Refresh(refresh_thumbnails);
 }
diff --git a/chrome/browser/media/webrtc/native_desktop_media_list.cc b/chrome/browser/media/webrtc/native_desktop_media_list.cc
index 312882d656f9f6b3d3fd98128131cea63f818e0d..be28789ccbd3cb8b28fa5ae4017305177a914e22 100644
--- a/chrome/browser/media/webrtc/native_desktop_media_list.cc
+++ b/chrome/browser/media/webrtc/native_desktop_media_list.cc
@@ -45,6 +45,7 @@
 #endif
 
 #if BUILDFLAG(IS_MAC)
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "components/remote_cocoa/browser/scoped_cg_window_id.h"
 #endif
 
@@ -162,9 +163,10 @@ content::DesktopMediaID::Type ConvertToDesktopMediaIDType(
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
-    case DesktopMediaList::Type::kNone:
       break;
   }
   NOTREACHED();
@@ -372,7 +374,8 @@ NativeDesktopMediaList::Worker::Worker(
                                 nullptr) {
   DCHECK(capturer_);
 
-  DCHECK(source_type_ == DesktopMediaID::Type::TYPE_WINDOW ||
+  DCHECK(source_type_ == DesktopMediaID::Type::TYPE_WINDOW || source_type_ ==
+             DesktopMediaID::Type::TYPE_NONE ||
          !add_current_process_windows_);
 }
 
@@ -505,11 +508,24 @@ NativeDesktopMediaList::Worker::FormatSources(
         break;
 
       case DesktopMediaID::Type::TYPE_WINDOW:
+      case DesktopMediaID::Type::TYPE_NONE:
+      #if BUILDFLAG(IS_MAC)
+              // If using NativeScreenCapturePickerMac,
+              // skipping the picker will skip the first window selection.
+              if (ShouldUseSCContentSharingPicker()) {
+                title = base::UTF8ToUTF16(sources[i].title);
+              } else if (sources[i].id == excluded_window_id) {
+              // Skip the picker dialog window.
+                continue;
+              }
+              title = base::UTF8ToUTF16(sources[i].title);
+      #else
         // Skip the picker dialog window.
         if (sources[i].id == excluded_window_id) {
           continue;
         }
         title = base::UTF8ToUTF16(sources[i].title);
+      #endif
         break;
 
       default:
@@ -775,14 +791,10 @@ NativeDesktopMediaList::NativeDesktopMediaList(
       is_source_list_delegated_(capturer->GetDelegatedSourceListController() !=
                                 nullptr) {
   type_ = type;
-
-  DCHECK(type_ == DesktopMediaList::Type::kWindow ||
+  DCHECK(type_ == DesktopMediaList::Type::kWindow || type_ == DesktopMediaList::Type::kNone ||
          !add_current_process_windows_);
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
-  // webrtc::DesktopCapturer implementations on Windows, MacOS and Fuchsia
-  // expect to run on a thread with a UI message pump. Under Fuchsia the
-  // capturer needs an async loop to support FIDL I/O.
   base::MessagePumpType thread_type = base::MessagePumpType::UI;
 #else
   base::MessagePumpType thread_type = base::MessagePumpType::DEFAULT;
@@ -794,8 +806,9 @@ NativeDesktopMediaList::NativeDesktopMediaList(
       std::move(capturer), add_current_process_windows_,
       auto_show_delegated_source_list);
 
-  if (!is_source_list_delegated_)
+  if (!is_source_list_delegated_) {
     StartCapturer();
+  }
 }
 
 NativeDesktopMediaList::~NativeDesktopMediaList() {
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
index 12a74f8f32cc00a7f3d7802865ae4b309961341d..acbcfb08ae8c44e24a04b326096289428bc6ff60 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
@@ -8,6 +8,9 @@
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
 #include "chrome/browser/media/webrtc/thumbnail_capturer.h"
 
+// Returns true if the SCK sharing picker is available and enabled.
+bool ShouldUseSCContentSharingPicker();
+
 // Returns true if the SCK thumbnail capturer is available and enabled.
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type);
 
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
index 744f2447dc2d43c4f6be695bf561474993468705..1eb7465481e3a2a70a99c173cae3e18f420a6681 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
@@ -13,6 +13,7 @@
 #include <optional>
 #include <unordered_map>
 
+#include "base/logging.h"
 #include "base/apple/bridging.h"
 #include "base/apple/foundation_util.h"
 #include "base/apple/scoped_cftyperef.h"
@@ -71,11 +72,11 @@
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
       return content::DesktopMediaID::Type::TYPE_WEB_CONTENTS;
-    case DesktopMediaList::Type::kNone:
-      break;
   }
   NOTREACHED();
 }
@@ -442,7 +443,7 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
       max_frame_rate_(kThumbnailCapturerMacMaxFrameRate),
       shareable_windows_([[NSArray<SCWindow*> alloc] init]) {
   CHECK(type_ == DesktopMediaList::Type::kWindow ||
-        type_ == DesktopMediaList::Type::kScreen);
+        type_ == DesktopMediaList::Type::kScreen || type_ == DesktopMediaList::Type::kNone);
 }
 
 ThumbnailCapturerMac::~ThumbnailCapturerMac() {
@@ -680,17 +681,18 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
                                       source_id);
 }
 
+}  // namespace
+
 bool ShouldUseSCContentSharingPicker() {
   if (@available(macOS 15.0, *)) {
     if (base::FeatureList::IsEnabled(media::kUseSCContentSharingPicker)) {
       return true;
     }
+    return false;
   }
   return false;
 }
 
-}  // namespace
-
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
   // There was a bug in ScreenCaptureKit that was fixed in 14.4,
   // see b/40076027.
@@ -704,6 +706,9 @@ bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
         return ShouldUseSCContentSharingPicker() ||
                base::FeatureList::IsEnabled(kScreenCaptureKitPickerScreen);
       case DesktopMediaList::Type::kNone:
+        return ShouldUseSCContentSharingPicker() ||
+               base::FeatureList::IsEnabled(kScreenCaptureKitStreamPickerSonoma) ||
+               base::FeatureList::IsEnabled(kScreenCaptureKitPickerScreen);
       case DesktopMediaList::Type::kCurrentTab:
       case DesktopMediaList::Type::kWebContents:
         return false;
diff --git a/content/browser/media/capture/desktop_capture_device.cc b/content/browser/media/capture/desktop_capture_device.cc
index b4b1e9ee805a8565a04737e0898ad8e46709c4d8..7b856f89028fe8f5594c1ff35900019250865ab5 100644
--- a/content/browser/media/capture/desktop_capture_device.cc
+++ b/content/browser/media/capture/desktop_capture_device.cc
@@ -899,7 +899,6 @@ std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
     result.reset(new DesktopCaptureDevice(std::move(capturer), source.type));
     return result;
   }
-
   switch (source.type) {
     case DesktopMediaID::TYPE_SCREEN: {
       std::unique_ptr<webrtc::DesktopCapturer> screen_capturer;
@@ -920,7 +919,7 @@ std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
       }
       break;
     }
-
+    case DesktopMediaID::TYPE_NONE:
     case DesktopMediaID::TYPE_WINDOW: {
       std::unique_ptr<webrtc::DesktopCapturer> window_capturer;
       if (auto generic_capturer =
diff --git a/content/browser/media/capture/native_screen_capture_picker.cc b/content/browser/media/capture/native_screen_capture_picker.cc
index 152f3aa78032ee3f8c48fbefe052a2f1d85bed6b..d57df80dff9c6867cddf669efe3f90c43c03a0a7 100644
--- a/content/browser/media/capture/native_screen_capture_picker.cc
+++ b/content/browser/media/capture/native_screen_capture_picker.cc
@@ -7,6 +7,7 @@
 #if BUILDFLAG(IS_MAC)
 #include "content/browser/media/capture/native_screen_capture_picker_mac.h"
 #include "media/base/media_switches.h"
+#include "base/logging.h"
 #endif
 
 namespace content {
diff --git a/content/browser/media/capture/native_screen_capture_picker_mac.mm b/content/browser/media/capture/native_screen_capture_picker_mac.mm
index 0dbc7ebc4ba6066eb6b20f8e66f50a1dff4d94f3..f36948241260f39665375a105c40d7725561d776 100644
--- a/content/browser/media/capture/native_screen_capture_picker_mac.mm
+++ b/content/browser/media/capture/native_screen_capture_picker_mac.mm
@@ -206,8 +206,11 @@ void Open(DesktopMediaID::Type type,
     base::OnceClosure cancel_callback,
     base::OnceClosure error_callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  // Chrome doesn't allow both screens & windows in their picker,
+  // but Electron does - add a check for TYPE_NONE.
   CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
-        type == DesktopMediaID::Type::TYPE_WINDOW);
+        type == DesktopMediaID::Type::TYPE_WINDOW ||
+        type == DesktopMediaID::Type::TYPE_NONE);
   if (@available(macOS 14.0, *)) {
     NSNumber* source_id = @(next_id_);
     PickerObserver* picker_observer = [[PickerObserver alloc]
@@ -226,25 +229,32 @@ void Open(DesktopMediaID::Type type,
     // TODO(https://crbug.com/360781940): Add support for changing selected
     // content. The problem to solve is how this should interact with stream
     // restart.
-    config.allowsChangingSelectedContent = false;
+    config.allowsChangingSelectedContent = true;
     NSNumber* max_stream_count = @(kMaxContentShareCountValue.Get());
-    if (type == DesktopMediaID::Type::TYPE_SCREEN) {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
-      VLOG(1) << "NSCPM: Show screen-sharing picker for source_id = "
-              << source_id.longValue;
-      LogToUma(SCContentSharingPickerOperation::kPresentScreen_Start);
-    } else {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
-      VLOG(1) << "NSCPM: Show window-sharing picker for source_id = "
-              << source_id.longValue;
-      LogToUma(SCContentSharingPickerOperation::kPresentWindow_Start);
-    }
+    // LOG(ERROR) << "Type: " << type;
+    // Chrome doesn't allow both screens & windows in their picker,
+    // but Electron does; we patch out the MediaID::Type conditional here
+    // if (type == DesktopMediaID::Type::TYPE_SCREEN) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
+    // } else if (type == DesktopMediaID::Type::TYPE_WINDOW) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
+    //   VLOG(1) << "NSCPM: Show screen-sharing picker for source_id = "
+    //           << source_id.longValue;
+    //   LogToUma(SCContentSharingPickerOperation::kPresentScreen_Start);
+    // } else {
+    picker.defaultConfiguration = config;
+    picker.maximumStreamCount = max_stream_count;
+    [picker present];
+    // VLOG(1) << "NSCPM: Show window-sharing picker for source_id = "
+    //         << source_id.longValue;
+    // LogToUma(SCContentSharingPickerOperation::kPresentWindow_Start);
+    // }
   } else {
     NOTREACHED();
   }
diff --git a/content/browser/media/capture/screen_capture_kit_device_mac.mm b/content/browser/media/capture/screen_capture_kit_device_mac.mm
index 0e4a68f2fd8179640f877cb258b4049610fd49da..0fb8d036b7696e5303fbcd463114114aa3227a08 100644
--- a/content/browser/media/capture/screen_capture_kit_device_mac.mm
+++ b/content/browser/media/capture/screen_capture_kit_device_mac.mm
@@ -364,6 +364,7 @@ void OnShareableContentCreated(SCShareableContent* content) {
             if (!fullscreen_module_) {
               fullscreen_module_ = MaybeCreateScreenCaptureKitFullscreenModule(
                   device_task_runner_, *this, window);
+            break;
             }
           }
         }
@@ -728,6 +729,7 @@ void ResetStreamTo(SCWindow* window) override {
     SCContentFilter* filter) {
   switch (source.type) {
     case DesktopMediaID::TYPE_SCREEN:
+    case DesktopMediaID::TYPE_NONE:
       // ScreenCaptureKitDeviceMac only supports a single display at a time.
       // It will not stitch desktops together. If
       // kScreenCaptureKitFullDesktopFallback is enabled, we will fallback to
diff --git a/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc b/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
index f0f08a834f06c7669da6030640434308a5cbd056..819c295157cc8240ea2f9034491fb998f67dc643 100644
--- a/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
+++ b/content/browser/renderer_host/media/in_process_video_capture_device_launcher.cc
@@ -177,19 +177,21 @@ DesktopCaptureImplementation CreatePlatformDependentVideoCaptureDevice(
 #if BUILDFLAG(IS_MAC)
   // Use ScreenCaptureKit with picker if specified. `desktop_id` for the picker
   // is not compatible with the other implementations.
-  if (picker) {
-    device_out = picker->CreateDevice(desktop_id);
-    if (device_out) {
-      return kScreenCaptureKitDeviceMac;
-    }
-    return kNoImplementation;
-  }
+  // if (picker) {
+  //   device_out = picker->CreateDevice(desktop_id);
+  //   if (device_out) {
+  //     return kScreenCaptureKitDeviceMac;
+  //   }
+  //   return kNoImplementation;
+  // }
 
   // Prefer using ScreenCaptureKit. After that try DesktopCaptureDeviceMac, and
   // if both fail, use the generic DesktopCaptureDevice.
   if (desktop_id.type == DesktopMediaID::TYPE_WINDOW ||
       (desktop_id.type == DesktopMediaID::TYPE_SCREEN &&
-       base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen))) {
+       base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen)) ||
+      (desktop_id.type == DesktopMediaID::TYPE_NONE &&
+       (base::FeatureList::IsEnabled(kScreenCaptureKitMacWindow) || base::FeatureList::IsEnabled(kScreenCaptureKitMacScreen)))) {
     device_out = CreateScreenCaptureKitDeviceMac(desktop_id);
     if (device_out) {
       return kScreenCaptureKitDeviceMac;
@@ -237,6 +239,9 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
   DCHECK(state_ == State::READY_TO_LAUNCH);
 
   if (receiver_on_io_thread) {
+    LOG(INFO) << "InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync: Posting "
+                 "start request to device thread for device_id = "
+              << device_id;
     std::ostringstream string_stream;
     string_stream
         << "InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync: Posting "
@@ -257,12 +262,14 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
       base::BindPostTaskToCurrentDefault(base::BindOnce(
           &InProcessVideoCaptureDeviceLauncher::OnDeviceStarted,
           base::Unretained(this), callbacks, std::move(done_cb)));
-
+  LOG(INFO) << "stream type: " << stream_type;
+  LOG(INFO) << "gum tab video capture: " << blink::mojom::MediaStreamType::GUM_TAB_VIDEO_CAPTURE;
   switch (stream_type) {
-    case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
-      // Only the Service-based device launcher is supported for device capture
-      // from cameras etc.
-      NOTREACHED();
+    // case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
+    //   // Only the Service-based device launcher is supported for device capture
+    //   // from cameras etc.
+    //   LOG(INFO) << "device video capture not reached";
+    //   NOTREACHED();
 #if BUILDFLAG(ENABLE_SCREEN_CAPTURE)
     case blink::mojom::MediaStreamType::GUM_TAB_VIDEO_CAPTURE:
       start_capture_closure = base::BindOnce(
@@ -274,10 +281,10 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
     case blink::mojom::MediaStreamType::GUM_DESKTOP_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE_THIS_TAB:
+    case blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE:
     case blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE_SET: {
       const DesktopMediaID desktop_id = DesktopMediaID::Parse(device_id);
-      if (desktop_id.is_null()) {
-        DLOG(ERROR) << "Desktop media ID is null";
+      if (desktop_id.is_null() && desktop_id.id != DesktopMediaID::kMacOsNativePickerId) {
         start_capture_closure =
             base::BindOnce(std::move(after_start_capture_callback), nullptr);
         break;
@@ -319,6 +326,7 @@ void InProcessVideoCaptureDeviceLauncher::LaunchDeviceAsync(
 #if defined(USE_AURA)
       bool allow_window_id = false;
 #elif BUILDFLAG(IS_MAC)
+
       bool allow_window_id =
         desktop_id.id == DesktopMediaID::kMacOsNativePickerId;
 #endif
@@ -505,7 +513,8 @@ void InProcessVideoCaptureDeviceLauncher::DoStartDesktopCaptureOnDeviceThread(
     std::unique_ptr<media::VideoCaptureDeviceClient> device_client,
     ReceiveDeviceCallback result_callback) {
   DCHECK(device_task_runner_->BelongsToCurrentThread());
-  DCHECK(!desktop_id.is_null());
+  LOG(INFO) << "desktop id: " << desktop_id.id;
+  // DCHECK(!desktop_id.is_null());
 
   std::unique_ptr<media::VideoCaptureDevice> video_capture_device;
   DesktopCaptureImplementation implementation =
diff --git a/content/browser/renderer_host/media/in_process_video_capture_provider.cc b/content/browser/renderer_host/media/in_process_video_capture_provider.cc
index 4462efa154a2be9cc25f82688fdbc7edf71a7bb1..4207dd1a79c16df5cc972943da32699f414f81fa 100644
--- a/content/browser/renderer_host/media/in_process_video_capture_provider.cc
+++ b/content/browser/renderer_host/media/in_process_video_capture_provider.cc
@@ -9,6 +9,7 @@
 #include "base/functional/bind.h"
 #include "base/task/single_thread_task_runner.h"
 #include "content/browser/renderer_host/media/in_process_video_capture_device_launcher.h"
+#include "content/browser/media/capture/native_screen_capture_picker.h"
 
 namespace content {
 
diff --git a/content/public/browser/desktop_media_id.cc b/content/public/browser/desktop_media_id.cc
index b39b684ff84baaf292eef1a23b7f9fb4585023c5..55507f7a782a9472800221f1e908618a5bad2914 100644
--- a/content/public/browser/desktop_media_id.cc
+++ b/content/public/browser/desktop_media_id.cc
@@ -21,6 +21,7 @@ namespace content {
 
 const char kScreenPrefix[] = "screen";
 const char kWindowPrefix[] = "window";
+const char kNonePrefix[] = "none";
 
 #if defined(USE_AURA) || BUILDFLAG(IS_MAC)
 // static
@@ -82,6 +83,8 @@ DesktopMediaID DesktopMediaID::Parse(const std::string& str) {
     type = TYPE_SCREEN;
   } else if (parts[0] == kWindowPrefix) {
     type = TYPE_WINDOW;
+  } else if (parts[0] == kNonePrefix) {
+    type = TYPE_NONE;
   } else {
     return DesktopMediaID();
   }
@@ -104,6 +107,8 @@ std::string DesktopMediaID::ToString() const {
   std::string prefix;
   switch (type) {
     case TYPE_NONE:
+      prefix = kNonePrefix;
+      break;
       NOTREACHED();
     case TYPE_SCREEN:
       prefix = kScreenPrefix;
